import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

// Time complexity - O (n x m); n - number of nodes, m - size of initial
// Space complexity - O (n); visited, infected, the recursion stack for DFS could go as deep as O (n)
public class MinimizeMalwareSpread {


    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;

        Arrays.sort(initial);

        int minInfectedNodes = Integer.MAX_VALUE;
        int bestNode = initial[0];

        for (int node : initial) {
            Set<Integer> currentInfectedNodes = new HashSet<>();
            for (int i : initial) {
                if (i != node) {
                    dfs(graph, i, currentInfectedNodes, new boolean[n]);
                }
            }

            if (currentInfectedNodes.size() < minInfectedNodes) {
                minInfectedNodes = currentInfectedNodes.size();
                bestNode = node;
            }
        }

        return bestNode;
    }

    private void dfs(int[][] graph, int node, Set<Integer> infectedNodes, boolean[] visited) {
        if (visited[node]) {
            return;
        }
        visited[node] = true;
        infectedNodes.add(node);

        for (int i = 0; i < graph.length; i++) {
            if (graph[node][i] == 1 && !visited[i]) {
                dfs(graph, i, infectedNodes, visited);
            }
        }
    }

}



